{"componentChunkName":"component-mdx.js","path":"/edge-certificates/custom-certificates/uploading","result":{"data":{"mdx":{"id":"54009a74-73ff-5edd-ae2d-8179b3fc5d09","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"order\": 1,\n  \"pcx-content-type\": \"how-to\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"uploading\"\n  }, \"Uploading\"), mdx(\"p\", null, \"Custom Certificates can be uploaded in the Cloudflare Dashboard or using the Cloudflare API.\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"certificate-packs\"\n  }, \"Certificate packs\"), mdx(\"p\", null, \"Certificates uploaded to Cloudflare will be automatically grouped together into a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://support.cloudflare.com/hc/en-us/articles/216532638-FAQ-Custom-Certificate-Packs-SHA-2-and-SHA-1-\"\n  }, \"Certificate Pack\"), \" before being deployed to the global edge. A Certificate Pack is a group of certificates that share the same set of hostnames, e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"example.com\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*.example.com\"), \", but use different signature algorithms. Each pack can include up to three certificates, with one from each of the following signature algorithms: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SHA-2/RSA\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SHA-2/ECDSA\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SHA-1/RSA\"), \".\"), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"certificate-requirements\"\n  }, \"Certificate requirements\"), mdx(\"p\", null, \"Certificates are parsed and checked for validity before being accepted. Each certificate uploaded must:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be encoded in PEM format\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Not be expiring in less than 14 days from time of upload\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Have a subject alternative name (SAN) matching at least one hostname in the zone where it\\u2019s being uploaded\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use a private key greater than or equal to a minimum length (currently 2048 bit for RSA and 225 bit for ECDSA)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be publicly trusted by a major browser, unless the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"User Defined\"), \" bundling method is used\")), mdx(\"hr\", null), mdx(\"h2\", {\n    \"id\": \"using-the-cloudflare-api\"\n  }, \"Using the Cloudflare API\"), mdx(\"p\", null, \"The call below will upload a certificate for use with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.example.com.\"\n  }, \"www.example.com.\"), \" Cloudflare will automatically bundle the certificate with a certificate chain optimized for maximum compatibility with browsers.\"), mdx(\"p\", null, \"Note that if you are using an ECC key generated by OpenSSL, you will need to first remove the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-----BEGIN EC PARAMETERS-----...-----END EC PARAMETERS-----\"), \" section of the file.\"), mdx(\"h3\", {\n    \"id\": \"1-prior-to-uploading-your-certificate-you-will-need-to-replace-line-endings-with-the-string-n-and-build-the-payload\"\n  }, \"1. Prior to uploading your certificate, you will need to replace line endings with the string \\u201C\\\\n\\u201D and build the payload\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ cat app_example_com.pem\\n-----BEGIN CERTIFICATE-----\\nMIIFJDCCBAygAwIBAgIQD0ifmj/Yi5NP/2gdUySbfzANBgkqhkiG9w0BAQsFADBN\\nMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E\\n...\\nSzSHfXp5lnu/3V08I72q1QNzOCgY1XeL4GKVcj4or6cT6tX6oJH7ePPmfrBfqI/O\\nOeH8gMJ+FuwtXYEPa4hBf38M5eU5xWG7\\n-----END CERTIFICATE-----\\n\\n$ MYCERT=\\\"$(cat www_example_com.pem|perl -pe 's/\\\\r?\\\\n/\\\\\\\\n/'|sed -e 's/..$//')\\\"\\n$ MYKEY=\\\"$(cat www_example_com.key|perl -pe 's/\\\\r?\\\\n/\\\\\\\\n/'|sed -e's/..$//')\\\"\\n\")), mdx(\"p\", null, \"With the certificate and key saved to environment variables (using escaped newlines), we build the payload:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ request_body=$(< <(cat <<EOF\\n{\\n    \\\"certificate\\\": \\\"$MYCERT\\\",\\n    \\\"private_key\\\": \\\"$MYKEY\\\",\\n    \\\"bundle_method\\\":\\\"ubiquitous\\\"\\n}\\nEOF\\n))\\n\")), mdx(\"p\", null, \"You can optionally add \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.cloudflare.com/introducing-cloudflare-geo-key-manager/\"\n  }, \"geographic restrictions\"), \" that specify where your private key can physically be decrypted:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ request_body=$(< <(cat <<EOF\\n{\\n    \\\"certificate\\\": \\\"$MYCERT\\\",\\n    \\\"private_key\\\": \\\"$MYKEY\\\",\\n    \\\"bundle_method\\\":\\\"ubiquitous\\\",\\n    \\\"geo_restrictions\\\":{\\\"label\\\":\\\"us\\\"}'\\n}\\n))\\n\")), mdx(\"p\", null, \"You can also enable support for legacy clients which do not include SNI in the TLS handshake.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ request_body=$(< <(cat <<EOF\\n{\\n    \\\"certificate\\\": \\\"$MYCERT\\\",\\n    \\\"private_key\\\": \\\"$MYKEY\\\",\\n    \\\"bundle_method\\\":\\\"ubiquitous\\\",\\n    \\\"geo_restrictions\\\":{\\\"label\\\":\\\"us\\\"}',\\n    \\\"type\\\":\\\"sni_custom\\\"\\n}\\n))\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sni_custom\"), \" is recommended by Cloudflare. Use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"legacy_custom\"), \" when a specific client requires non-SNI support. The Cloudflare API treats all Custom SSL certificates as Legacy by default.  \"), mdx(\"h3\", {\n    \"id\": \"2-with-the-payload-built-make-the-api-call-to-upload-your-certificate-and-key\"\n  }, \"2. With the payload built, make the API call to upload your certificate and key\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"$ curl -sX POST https://api.cloudflare.com/client/v4/zones/{zone_id}/custom_certificates \\\\\\n     -H \\\"X-Auth-Email: {email}\\\" -H \\\"X-Auth-Key: {key}\\\" \\\\\\n     -H \\\"Content-Type: application/json\\\" -d \\\"$request_body\\\"\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"demo":null,"difficulty":null,"summary":null,"tags":null,"title":"","type":null,"updated":null}}},"pageContext":{"id":"54009a74-73ff-5edd-ae2d-8179b3fc5d09","fields":{"slug":"/edge-certificates/custom-certificates/uploading"},"frontmatter":{"title":"","type":null,"order":1,"hidden":null,"hideChildren":null,"breadcrumbs":null},"headings":[{"value":"Uploading","depth":1}],"tableOfContents":{"items":[{"url":"#uploading","title":"Uploading","items":[{"url":"#certificate-packs","title":"Certificate packs"},{"url":"#certificate-requirements","title":"Certificate requirements"},{"url":"#using-the-cloudflare-api","title":"Using the Cloudflare API","items":[{"url":"#1-prior-to-uploading-your-certificate-you-will-need-to-replace-line-endings-with-the-string-n-and-build-the-payload","title":"1. Prior to uploading your certificate, you will need to replace line endings with the string “\\n” and build the payload"},{"url":"#2-with-the-payload-built-make-the-api-call-to-upload-your-certificate-and-key","title":"2. With the payload built, make the API call to upload your certificate and key"}]}]}]},"parent":{"modifiedTime":"2021-07-26","relativePath":"edge-certificates/custom-certificates/uploading.md"}}},"staticQueryHashes":["1052658729","2814688963","32046230","123456789","811020565"]}